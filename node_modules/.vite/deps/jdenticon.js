import {
  __commonJS
} from "./chunk-34KZWS7D.js";

// node_modules/jdenticon/dist/jdenticon-module.js
var require_jdenticon_module = __commonJS({
  "node_modules/jdenticon/dist/jdenticon-module.js"(exports, module) {
    function parseHex(hash, startPosition, octets) {
      return parseInt(hash.substr(startPosition, octets), 16);
    }
    function decToHex(v) {
      v |= 0;
      return v < 0 ? "00" : v < 16 ? "0" + v.toString(16) : v < 256 ? v.toString(16) : "ff";
    }
    function hueToRgb(m1, m2, h) {
      h = h < 0 ? h + 6 : h > 6 ? h - 6 : h;
      return decToHex(255 * (h < 1 ? m1 + (m2 - m1) * h : h < 3 ? m2 : h < 4 ? m1 + (m2 - m1) * (4 - h) : m1));
    }
    function parseColor(color) {
      if (/^#[0-9a-f]{3,8}$/i.test(color)) {
        var result;
        var colorLength = color.length;
        if (colorLength < 6) {
          var r = color[1], g = color[2], b = color[3], a = color[4] || "";
          result = "#" + r + r + g + g + b + b + a + a;
        }
        if (colorLength == 7 || colorLength > 8) {
          result = color;
        }
        return result;
      }
    }
    function toCss3Color(hexColor) {
      var a = parseHex(hexColor, 7, 2);
      var result;
      if (isNaN(a)) {
        result = hexColor;
      } else {
        var r = parseHex(hexColor, 1, 2), g = parseHex(hexColor, 3, 2), b = parseHex(hexColor, 5, 2);
        result = "rgba(" + r + "," + g + "," + b + "," + (a / 255).toFixed(2) + ")";
      }
      return result;
    }
    function hsl(hue, saturation, lightness) {
      var result;
      if (saturation == 0) {
        var partialHex = decToHex(lightness * 255);
        result = partialHex + partialHex + partialHex;
      } else {
        var m2 = lightness <= 0.5 ? lightness * (saturation + 1) : lightness + saturation - lightness * saturation, m1 = lightness * 2 - m2;
        result = hueToRgb(m1, m2, hue * 6 + 2) + hueToRgb(m1, m2, hue * 6) + hueToRgb(m1, m2, hue * 6 - 2);
      }
      return "#" + result;
    }
    function correctedHsl(hue, saturation, lightness) {
      var correctors = [0.55, 0.5, 0.5, 0.46, 0.6, 0.55, 0.55], corrector = correctors[hue * 6 + 0.5 | 0];
      lightness = lightness < 0.5 ? lightness * corrector * 2 : corrector + (lightness - 0.5) * (1 - corrector) * 2;
      return hsl(hue, saturation, lightness);
    }
    var GLOBAL = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};
    var CONFIG_PROPERTIES = {
      W: "jdenticon_config",
      n: "config"
    };
    var rootConfigurationHolder = {};
    function defineConfigProperty(rootObject) {
      rootConfigurationHolder = rootObject;
    }
    function configure(newConfiguration) {
      if (arguments.length) {
        rootConfigurationHolder[
          CONFIG_PROPERTIES.n
          /*MODULE*/
        ] = newConfiguration;
      }
      return rootConfigurationHolder[
        CONFIG_PROPERTIES.n
        /*MODULE*/
      ];
    }
    function getConfiguration(paddingOrLocalConfig, defaultPadding) {
      var configObject = typeof paddingOrLocalConfig == "object" && paddingOrLocalConfig || rootConfigurationHolder[
        CONFIG_PROPERTIES.n
        /*MODULE*/
      ] || GLOBAL[
        CONFIG_PROPERTIES.W
        /*GLOBAL*/
      ] || {}, lightnessConfig = configObject["lightness"] || {}, saturation = configObject["saturation"] || {}, colorSaturation = "color" in saturation ? saturation["color"] : saturation, grayscaleSaturation = saturation["grayscale"], backColor = configObject["backColor"], padding = configObject["padding"];
      function lightness(configName, defaultRange) {
        var range = lightnessConfig[configName];
        if (!(range && range.length > 1)) {
          range = defaultRange;
        }
        return function(value) {
          value = range[0] + value * (range[1] - range[0]);
          return value < 0 ? 0 : value > 1 ? 1 : value;
        };
      }
      function hueFunction(originalHue) {
        var hueConfig = configObject["hues"];
        var hue;
        if (hueConfig && hueConfig.length > 0) {
          hue = hueConfig[0 | 0.999 * originalHue * hueConfig.length];
        }
        return typeof hue == "number" ? (
          // A hue was specified. We need to convert the hue from
          // degrees on any turn - e.g. 746Â° is a perfectly valid hue -
          // to turns in the range [0, 1).
          (hue / 360 % 1 + 1) % 1
        ) : (
          // No hue configured => use original hue
          originalHue
        );
      }
      return {
        X: hueFunction,
        o: typeof colorSaturation == "number" ? colorSaturation : 0.5,
        F: typeof grayscaleSaturation == "number" ? grayscaleSaturation : 0,
        p: lightness("color", [0.4, 0.8]),
        G: lightness("grayscale", [0.3, 0.9]),
        H: parseColor(backColor),
        Y: typeof paddingOrLocalConfig == "number" ? paddingOrLocalConfig : typeof padding == "number" ? padding : defaultPadding
      };
    }
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }
    function Transform(x, y, size, rotation) {
      this.q = x;
      this.t = y;
      this.I = size;
      this.Z = rotation;
    }
    Transform.prototype.J = function transformIconPoint(x, y, w, h) {
      var right = this.q + this.I, bottom = this.t + this.I, rotation = this.Z;
      return rotation === 1 ? new Point(right - y - (h || 0), this.t + x) : rotation === 2 ? new Point(right - x - (w || 0), bottom - y - (h || 0)) : rotation === 3 ? new Point(this.q + y, bottom - x - (w || 0)) : new Point(this.q + x, this.t + y);
    };
    var NO_TRANSFORM = new Transform(0, 0, 0, 0);
    function Graphics(renderer) {
      this.K = renderer;
      this.u = NO_TRANSFORM;
    }
    var Graphics__prototype = Graphics.prototype;
    Graphics__prototype.g = function addPolygon(points, invert) {
      var this$1 = this;
      var di = invert ? -2 : 2, transformedPoints = [];
      for (var i = invert ? points.length - 2 : 0; i < points.length && i >= 0; i += di) {
        transformedPoints.push(this$1.u.J(points[i], points[i + 1]));
      }
      this.K.g(transformedPoints);
    };
    Graphics__prototype.h = function addCircle(x, y, size, invert) {
      var p = this.u.J(x, y, size, size);
      this.K.h(p, size, invert);
    };
    Graphics__prototype.i = function addRectangle(x, y, w, h, invert) {
      this.g([
        x,
        y,
        x + w,
        y,
        x + w,
        y + h,
        x,
        y + h
      ], invert);
    };
    Graphics__prototype.j = function addTriangle(x, y, w, h, r, invert) {
      var points = [
        x + w,
        y,
        x + w,
        y + h,
        x,
        y + h,
        x,
        y
      ];
      points.splice((r || 0) % 4 * 2, 2);
      this.g(points, invert);
    };
    Graphics__prototype.L = function addRhombus(x, y, w, h, invert) {
      this.g([
        x + w / 2,
        y,
        x + w,
        y + h / 2,
        x + w / 2,
        y + h,
        x,
        y + h / 2
      ], invert);
    };
    function centerShape(index, g, cell, positionIndex) {
      index = index % 14;
      var k, m, w, h, inner, outer;
      !index ? (k = cell * 0.42, g.g([
        0,
        0,
        cell,
        0,
        cell,
        cell - k * 2,
        cell - k,
        cell,
        0,
        cell
      ])) : index == 1 ? (w = 0 | cell * 0.5, h = 0 | cell * 0.8, g.j(cell - w, 0, w, h, 2)) : index == 2 ? (w = 0 | cell / 3, g.i(w, w, cell - w, cell - w)) : index == 3 ? (inner = cell * 0.1, // Use fixed outer border widths in small icons to ensure the border is drawn
      outer = cell < 6 ? 1 : cell < 8 ? 2 : 0 | cell * 0.25, inner = inner > 1 ? 0 | inner : (
        // large icon => truncate decimals
        inner > 0.5 ? 1 : (
          // medium size icon => fixed width
          inner
        )
      ), // small icon => anti-aliased border
      g.i(outer, outer, cell - inner - outer, cell - inner - outer)) : index == 4 ? (m = 0 | cell * 0.15, w = 0 | cell * 0.5, g.h(cell - w - m, cell - w - m, w)) : index == 5 ? (inner = cell * 0.1, outer = inner * 4, // Align edge to nearest pixel in large icons
      outer > 3 && (outer = 0 | outer), g.i(0, 0, cell, cell), g.g([
        outer,
        outer,
        cell - inner,
        outer,
        outer + (cell - outer - inner) / 2,
        cell - inner
      ], true)) : index == 6 ? g.g([
        0,
        0,
        cell,
        0,
        cell,
        cell * 0.7,
        cell * 0.4,
        cell * 0.4,
        cell * 0.7,
        cell,
        0,
        cell
      ]) : index == 7 ? g.j(cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 8 ? (g.i(0, 0, cell, cell / 2), g.i(0, cell / 2, cell / 2, cell / 2), g.j(cell / 2, cell / 2, cell / 2, cell / 2, 1)) : index == 9 ? (inner = cell * 0.14, // Use fixed outer border widths in small icons to ensure the border is drawn
      outer = cell < 4 ? 1 : cell < 6 ? 2 : 0 | cell * 0.35, inner = cell < 8 ? inner : (
        // small icon => anti-aliased border
        0 | inner
      ), // large icon => truncate decimals
      g.i(0, 0, cell, cell), g.i(outer, outer, cell - outer - inner, cell - outer - inner, true)) : index == 10 ? (inner = cell * 0.12, outer = inner * 3, g.i(0, 0, cell, cell), g.h(outer, outer, cell - inner - outer, true)) : index == 11 ? g.j(cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 12 ? (m = cell * 0.25, g.i(0, 0, cell, cell), g.L(m, m, cell - m, cell - m, true)) : (
        // 13
        !positionIndex && (m = cell * 0.4, w = cell * 1.2, g.h(m, m, w))
      );
    }
    function outerShape(index, g, cell) {
      index = index % 4;
      var m;
      !index ? g.j(0, 0, cell, cell, 0) : index == 1 ? g.j(0, cell / 2, cell, cell / 2, 0) : index == 2 ? g.L(0, 0, cell, cell) : (
        // 3
        (m = cell / 6, g.h(m, m, cell - 2 * m))
      );
    }
    function colorTheme(hue, config) {
      hue = config.X(hue);
      return [
        // Dark gray
        correctedHsl(hue, config.F, config.G(0)),
        // Mid color
        correctedHsl(hue, config.o, config.p(0.5)),
        // Light gray
        correctedHsl(hue, config.F, config.G(1)),
        // Light color
        correctedHsl(hue, config.o, config.p(1)),
        // Dark color
        correctedHsl(hue, config.o, config.p(0))
      ];
    }
    function iconGenerator(renderer, hash, config) {
      var parsedConfig = getConfiguration(config, 0.08);
      if (parsedConfig.H) {
        renderer.m(
          parsedConfig.H
          /*backColor*/
        );
      }
      var size = renderer.k;
      var padding = 0.5 + size * parsedConfig.Y | 0;
      size -= padding * 2;
      var graphics = new Graphics(renderer);
      var cell = 0 | size / 4;
      var x = 0 | padding + size / 2 - cell * 2;
      var y = 0 | padding + size / 2 - cell * 2;
      function renderShape(colorIndex, shapes, index2, rotationIndex, positions) {
        var shapeIndex = parseHex(hash, index2, 1);
        var r = rotationIndex ? parseHex(hash, rotationIndex, 1) : 0;
        renderer.M(availableColors[selectedColorIndexes[colorIndex]]);
        for (var i2 = 0; i2 < positions.length; i2++) {
          graphics.u = new Transform(x + positions[i2][0] * cell, y + positions[i2][1] * cell, cell, r++ % 4);
          shapes(shapeIndex, graphics, cell, i2);
        }
        renderer.N();
      }
      var hue = parseHex(hash, -7) / 268435455, availableColors = colorTheme(hue, parsedConfig), selectedColorIndexes = [];
      var index;
      function isDuplicate(values) {
        if (values.indexOf(index) >= 0) {
          for (var i2 = 0; i2 < values.length; i2++) {
            if (selectedColorIndexes.indexOf(values[i2]) >= 0) {
              return true;
            }
          }
        }
      }
      for (var i = 0; i < 3; i++) {
        index = parseHex(hash, 8 + i, 1) % availableColors.length;
        if (isDuplicate([0, 4]) || // Disallow dark gray and dark color combo
        isDuplicate([2, 3])) {
          index = 1;
        }
        selectedColorIndexes.push(index);
      }
      renderShape(0, outerShape, 2, 3, [[1, 0], [2, 0], [2, 3], [1, 3], [0, 1], [3, 1], [3, 2], [0, 2]]);
      renderShape(1, outerShape, 4, 5, [[0, 0], [3, 0], [3, 3], [0, 3]]);
      renderShape(2, centerShape, 1, null, [[1, 1], [2, 1], [2, 2], [1, 2]]);
      renderer.finish();
    }
    function sha1(message) {
      var HASH_SIZE_HALF_BYTES = 40;
      var BLOCK_SIZE_WORDS = 16;
      var i = 0, f = 0, urlEncodedMessage = encodeURI(message) + "%80", data = [], dataSize, hashBuffer = [], a = 1732584193, b = 4023233417, c = ~a, d = ~b, e = 3285377520, hash = [a, b, c, d, e], blockStartIndex = 0, hexHash = "";
      function rotl(value, shift) {
        return value << shift | value >>> 32 - shift;
      }
      for (; i < urlEncodedMessage.length; f++) {
        data[f >> 2] = data[f >> 2] | (urlEncodedMessage[i] == "%" ? parseInt(urlEncodedMessage.substring(i + 1, i += 3), 16) : urlEncodedMessage.charCodeAt(i++)) << (3 - (f & 3)) * 8;
      }
      dataSize = ((f + 7 >> 6) + 1) * BLOCK_SIZE_WORDS;
      data[dataSize - 1] = f * 8 - 8;
      for (; blockStartIndex < dataSize; blockStartIndex += BLOCK_SIZE_WORDS) {
        for (i = 0; i < 80; i++) {
          f = rotl(a, 5) + e + // Ch
          (i < 20 ? (b & c ^ ~b & d) + 1518500249 : (
            // Parity
            i < 40 ? (b ^ c ^ d) + 1859775393 : (
              // Maj
              i < 60 ? (b & c ^ b & d ^ c & d) + 2400959708 : (
                // Parity
                (b ^ c ^ d) + 3395469782
              )
            )
          )) + (hashBuffer[i] = i < BLOCK_SIZE_WORDS ? data[blockStartIndex + i] | 0 : rotl(hashBuffer[i - 3] ^ hashBuffer[i - 8] ^ hashBuffer[i - 14] ^ hashBuffer[i - 16], 1));
          e = d;
          d = c;
          c = rotl(b, 30);
          b = a;
          a = f;
        }
        hash[0] = a = hash[0] + a | 0;
        hash[1] = b = hash[1] + b | 0;
        hash[2] = c = hash[2] + c | 0;
        hash[3] = d = hash[3] + d | 0;
        hash[4] = e = hash[4] + e | 0;
      }
      for (i = 0; i < HASH_SIZE_HALF_BYTES; i++) {
        hexHash += // Get word (2^3 half-bytes per word)
        (hash[i >> 3] >>> // Append half-bytes in reverse order
        (7 - (i & 7)) * 4 & 15).toString(16);
      }
      return hexHash;
    }
    function isValidHash(hashCandidate) {
      return /^[0-9a-f]{11,}$/i.test(hashCandidate) && hashCandidate;
    }
    function computeHash(value) {
      return sha1(value == null ? "" : "" + value);
    }
    function CanvasRenderer(ctx, iconSize) {
      var canvas = ctx.canvas;
      var width = canvas.width;
      var height = canvas.height;
      ctx.save();
      if (!iconSize) {
        iconSize = Math.min(width, height);
        ctx.translate(
          (width - iconSize) / 2 | 0,
          (height - iconSize) / 2 | 0
        );
      }
      this.l = ctx;
      this.k = iconSize;
      ctx.clearRect(0, 0, iconSize, iconSize);
    }
    var CanvasRenderer__prototype = CanvasRenderer.prototype;
    CanvasRenderer__prototype.m = function setBackground(fillColor) {
      var ctx = this.l;
      var iconSize = this.k;
      ctx.fillStyle = toCss3Color(fillColor);
      ctx.fillRect(0, 0, iconSize, iconSize);
    };
    CanvasRenderer__prototype.M = function beginShape(fillColor) {
      var ctx = this.l;
      ctx.fillStyle = toCss3Color(fillColor);
      ctx.beginPath();
    };
    CanvasRenderer__prototype.N = function endShape() {
      this.l.fill();
    };
    CanvasRenderer__prototype.g = function addPolygon(points) {
      var ctx = this.l;
      ctx.moveTo(points[0].x, points[0].y);
      for (var i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.closePath();
    };
    CanvasRenderer__prototype.h = function addCircle(point, diameter, counterClockwise) {
      var ctx = this.l, radius = diameter / 2;
      ctx.moveTo(point.x + radius, point.y + radius);
      ctx.arc(point.x + radius, point.y + radius, radius, 0, Math.PI * 2, counterClockwise);
      ctx.closePath();
    };
    CanvasRenderer__prototype.finish = function finish() {
      this.l.restore();
    };
    function drawIcon(ctx, hashOrValue, size, config) {
      if (!ctx) {
        throw new Error("No canvas specified.");
      }
      iconGenerator(
        new CanvasRenderer(ctx, size),
        isValidHash(hashOrValue) || computeHash(hashOrValue),
        config
      );
    }
    function svgValue(value) {
      return (value * 10 + 0.5 | 0) / 10;
    }
    function SvgPath() {
      this.v = "";
    }
    var SvgPath__prototype = SvgPath.prototype;
    SvgPath__prototype.g = function addPolygon(points) {
      var dataString = "";
      for (var i = 0; i < points.length; i++) {
        dataString += (i ? "L" : "M") + svgValue(points[i].x) + " " + svgValue(points[i].y);
      }
      this.v += dataString + "Z";
    };
    SvgPath__prototype.h = function addCircle(point, diameter, counterClockwise) {
      var sweepFlag = counterClockwise ? 0 : 1, svgRadius = svgValue(diameter / 2), svgDiameter = svgValue(diameter), svgArc = "a" + svgRadius + "," + svgRadius + " 0 1," + sweepFlag + " ";
      this.v += "M" + svgValue(point.x) + " " + svgValue(point.y + diameter / 2) + svgArc + svgDiameter + ",0" + svgArc + -svgDiameter + ",0";
    };
    function SvgRenderer(target) {
      this.A;
      this.B = {};
      this.O = target;
      this.k = target.k;
    }
    var SvgRenderer__prototype = SvgRenderer.prototype;
    SvgRenderer__prototype.m = function setBackground(fillColor) {
      var match = /^(#......)(..)?/.exec(fillColor), opacity = match[2] ? parseHex(match[2], 0) / 255 : 1;
      this.O.m(match[1], opacity);
    };
    SvgRenderer__prototype.M = function beginShape(color) {
      this.A = this.B[color] || (this.B[color] = new SvgPath());
    };
    SvgRenderer__prototype.N = function endShape() {
    };
    SvgRenderer__prototype.g = function addPolygon(points) {
      this.A.g(points);
    };
    SvgRenderer__prototype.h = function addCircle(point, diameter, counterClockwise) {
      this.A.h(point, diameter, counterClockwise);
    };
    SvgRenderer__prototype.finish = function finish() {
      var this$1 = this;
      var pathsByColor = this.B;
      for (var color in pathsByColor) {
        if (pathsByColor.hasOwnProperty(color)) {
          this$1.O.P(
            color,
            pathsByColor[color].v
            /*dataString*/
          );
        }
      }
    };
    var SVG_CONSTANTS = {
      R: "http://www.w3.org/2000/svg",
      S: "width",
      T: "height"
    };
    function SvgWriter(iconSize) {
      this.k = iconSize;
      this.C = '<svg xmlns="' + SVG_CONSTANTS.R + '" width="' + iconSize + '" height="' + iconSize + '" viewBox="0 0 ' + iconSize + " " + iconSize + '">';
    }
    var SvgWriter__prototype = SvgWriter.prototype;
    SvgWriter__prototype.m = function setBackground(fillColor, opacity) {
      if (opacity) {
        this.C += '<rect width="100%" height="100%" fill="' + fillColor + '" opacity="' + opacity.toFixed(2) + '"/>';
      }
    };
    SvgWriter__prototype.P = function appendPath(color, dataString) {
      this.C += '<path fill="' + color + '" d="' + dataString + '"/>';
    };
    SvgWriter__prototype.toString = function toString() {
      return this.C + "</svg>";
    };
    function toSvg(hashOrValue, size, config) {
      var writer = new SvgWriter(size);
      iconGenerator(
        new SvgRenderer(writer),
        isValidHash(hashOrValue) || computeHash(hashOrValue),
        config
      );
      return writer.toString();
    }
    var ICON_TYPE_SVG = 1;
    var ICON_TYPE_CANVAS = 2;
    var ATTRIBUTES = {
      U: "data-jdenticon-hash",
      D: "data-jdenticon-value"
    };
    var ICON_SELECTOR = "[" + ATTRIBUTES.U + "],[" + ATTRIBUTES.D + "]";
    var documentQuerySelectorAll = (
      /** @type {!Function} */
      typeof document !== "undefined" && document.querySelectorAll.bind(document)
    );
    function getIdenticonType(el) {
      if (el) {
        var tagName = el["tagName"];
        if (/^svg$/i.test(tagName)) {
          return ICON_TYPE_SVG;
        }
        if (/^canvas$/i.test(tagName) && "getContext" in el) {
          return ICON_TYPE_CANVAS;
        }
      }
    }
    function SvgElement_append(parentNode, name) {
      var keyValuePairs = [], len = arguments.length - 2;
      while (len-- > 0)
        keyValuePairs[len] = arguments[len + 2];
      var el = document.createElementNS(SVG_CONSTANTS.R, name);
      for (var i = 0; i + 1 < keyValuePairs.length; i += 2) {
        el.setAttribute(
          /** @type {string} */
          keyValuePairs[i],
          /** @type {string} */
          keyValuePairs[i + 1]
        );
      }
      parentNode.appendChild(el);
    }
    function SvgElement(element) {
      var iconSize = this.k = Math.min(
        Number(element.getAttribute(
          SVG_CONSTANTS.S
          /*WIDTH*/
        )) || 100,
        Number(element.getAttribute(
          SVG_CONSTANTS.T
          /*HEIGHT*/
        )) || 100
      );
      this.V = element;
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
      element.setAttribute("viewBox", "0 0 " + iconSize + " " + iconSize);
      element.setAttribute("preserveAspectRatio", "xMidYMid meet");
    }
    var SvgElement__prototype = SvgElement.prototype;
    SvgElement__prototype.m = function setBackground(fillColor, opacity) {
      if (opacity) {
        SvgElement_append(
          this.V,
          "rect",
          SVG_CONSTANTS.S,
          "100%",
          SVG_CONSTANTS.T,
          "100%",
          "fill",
          fillColor,
          "opacity",
          opacity
        );
      }
    };
    SvgElement__prototype.P = function appendPath(color, dataString) {
      SvgElement_append(
        this.V,
        "path",
        "fill",
        color,
        "d",
        dataString
      );
    };
    function updateAll() {
      if (documentQuerySelectorAll) {
        update(ICON_SELECTOR);
      }
    }
    function update(el, hashOrValue, config) {
      renderDomElement(el, hashOrValue, config, function(el2, iconType) {
        if (iconType) {
          return iconType == ICON_TYPE_SVG ? new SvgRenderer(new SvgElement(el2)) : new CanvasRenderer(
            /** @type {HTMLCanvasElement} */
            el2.getContext("2d")
          );
        }
      });
    }
    function updateCanvas(el, hashOrValue, config) {
      renderDomElement(el, hashOrValue, config, function(el2, iconType) {
        if (iconType == ICON_TYPE_CANVAS) {
          return new CanvasRenderer(
            /** @type {HTMLCanvasElement} */
            el2.getContext("2d")
          );
        }
      });
    }
    function updateSvg(el, hashOrValue, config) {
      renderDomElement(el, hashOrValue, config, function(el2, iconType) {
        if (iconType == ICON_TYPE_SVG) {
          return new SvgRenderer(new SvgElement(el2));
        }
      });
    }
    function renderDomElement(el, hashOrValue, config, rendererFactory) {
      if (typeof el === "string") {
        if (documentQuerySelectorAll) {
          var elements = documentQuerySelectorAll(el);
          for (var i = 0; i < elements.length; i++) {
            renderDomElement(elements[i], hashOrValue, config, rendererFactory);
          }
        }
        return;
      }
      var hash = (
        // 1. Explicit valid hash
        isValidHash(hashOrValue) || // 2. Explicit value (`!= null` catches both null and undefined)
        hashOrValue != null && computeHash(hashOrValue) || // 3. `data-jdenticon-hash` attribute
        isValidHash(el.getAttribute(
          ATTRIBUTES.U
          /*HASH*/
        )) || // 4. `data-jdenticon-value` attribute. 
        // We want to treat an empty attribute as an empty value. 
        // Some browsers return empty string even if the attribute 
        // is not specified, so use hasAttribute to determine if 
        // the attribute is specified.
        el.hasAttribute(
          ATTRIBUTES.D
          /*VALUE*/
        ) && computeHash(el.getAttribute(
          ATTRIBUTES.D
          /*VALUE*/
        ))
      );
      if (!hash) {
        return;
      }
      var renderer = rendererFactory(el, getIdenticonType(el));
      if (renderer) {
        iconGenerator(renderer, hash, config);
      }
    }
    var jdenticon = updateAll;
    defineConfigProperty(jdenticon);
    jdenticon["configure"] = configure;
    jdenticon["drawIcon"] = drawIcon;
    jdenticon["toSvg"] = toSvg;
    jdenticon["update"] = update;
    jdenticon["updateCanvas"] = updateCanvas;
    jdenticon["updateSvg"] = updateSvg;
    jdenticon["version"] = "3.2.0";
    jdenticon["bundle"] = "browser-cjs";
    module.exports = jdenticon;
  }
});
export default require_jdenticon_module();
//# sourceMappingURL=jdenticon.js.map
